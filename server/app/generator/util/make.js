const DiceExpression = require("dice-expression-evaluator");
const fng = require("fantasy-names");

const Instance = require("../../instance/Instance");

const { toUpper, rand } = require("../../util");
const colorConvertRequire = require("../../util/colorConvert");
const colorConvert = Object.assign({}, colorConvertRequire, {
	tan: colorConvertRequire["khaki"],
	silvery: colorConvertRequire["silver"],
	red: colorConvertRequire["darkred"],
	shady: colorConvertRequire["grey"],
	blue: colorConvertRequire["darkblue"],
	multicolored: "grey-100 ptn-rainbow",
	golden: colorConvertRequire["gold"],
	shimmering: "grey-1000 ptn-glow",
	glowing: "grey-1000 ptn-glow",
	luminous: "grey-1000 ptn-glow",
	faint: colorConvertRequire["white"],
	pale: colorConvertRequire["white"],
	opaline: "amber-50"
});

class Maker {
	constructor({ builtpack, tables = [] }) {
		this.builtpack = builtpack;
		this.tables = tables;
		this.Generator = builtpack.model("Generator");
	}

	getTable(_id) {
		let table = this.tables.find(t => t._id.equals(_id));
		if (!table) {
			console.error(`need to get Table ${_id}`);
			// todo: recursive query
			//table = await this.Table.findById(table);
		}
		return table;
	}

	/**
	 * Creates a random version of a generator
	 * @param  {Object|Generator} gen         the generator
	 * @param  {Integer} generations the number of nested levels to generate
	 * @param  {BuiltPack} builtpack        the compiled built pack with combined definitions of generators to use
	 * @param {Object} node the pre-existing node that we are generating children for
	 * @return {Nested}             the node that will be passed to the user
	 */
	// eslint-disable-next-line max-statements, complexity
	make(gen, generations, node, ancestorData = {}) {
		if (isNaN(generations) || generations < 0) generations = 0;
		const isEmbedded = !gen.isa;

		//make into a Generator obj if not
		gen = this.cleanGen(gen, this.builtpack);
		const data = Object.assign({}, ancestorData, gen.data);

		// make a new node if doesn't exist yet
		if (!node) {
			let name = this.makeMixedThing(gen.name, data);
			let style = this.makeStyle(gen, name);
			let desc = gen.desc ? gen.desc.map(d => this.makeMixedThing(d, data)) : [];
			node = new Instance({ name, isa: gen.isa, ...style, desc, data: gen.data });
		}

		// we have to keep going on embedded generators or we will lose the definition forever
		if (!isEmbedded) {
			// no children, we're done!
			if (!gen.in || !gen.in.length) return node;
			// we're just out of generations, but we could go further later;
			else if (generations <= 0) {
				if (node.isa) {
					node.todo = true;
				}
				return node;
			}
		}

		// in ---------------------------------------------

		// make children
		const madeChildren = gen.in.map(c => {
			return this.makeChild(c, generations - 1, data);
		});

		//flatten madeChildren into single array
		var flatArray = [];
		madeChildren.forEach(child => {
			flatArray = flatArray.concat(child);
		});

		let inArr = !flatArray || !flatArray.length ? undefined : flatArray;

		// todo: get instances and push in
		node.TEMP_IN = inArr;
		return node;
	}

	/**
	 * Processes the type of a child to randomly generate it
	 * @param  {Object} child       childSchema
	 * @param  {BuiltPack} builtpack   the compiled pack
	 * @param  {Integer} generations the number of nested levels to generate
	 * @return {Object[]}             an array of nodes that was generated by this child
	 */
	// eslint-disable-next-line complexity
	makeChild(child, generations, ancestorData = {}) {
		if (!child || !this.builtpack) return [];

		var arr = [];
		const Generator = this.Generator;

		// wrap as a child if needed
		if (!child.model) child = new Generator({ in: [child] }).in[0];

		var amount = child.makeAmount;

		var { gen, table } = this.checkTypes(child, ancestorData);

		if (!amount || !child.isIncluded) return [];

		for (var i = 0; i < amount; i++) {
			if (gen) {
				arr.push(this.make(gen, generations, undefined, ancestorData));
			} else if (table) {
				var result = this.roll(table);
				if (typeof result === undefined) continue;
				if (typeof result === "string") result = { value: result, type: "string" };
				arr = arr.concat(this.makeChild(result, generations, ancestorData));
			} else if (child.value) {
				arr.push(
					new Instance({
						name: child.value,
						up: []
					})
				);
			}
		}

		return arr;
	}

	/**
	 * Make a thing that could be a tableid, a table, or a string
	 * @param  {string} options.type  tableid, table, or string
	 * @param  {Object|string} options.value the thing
	 * @param  {Table} Table         the table schema
	 * @return {string}              the random value
	 */
	// eslint-disable-next-line complexity
	makeMixedThing(thing, data = {}) {
		if (typeof thing === "string" || !thing) return thing;

		var { type, value } = thing;
		if (type === undefined || value === undefined || value === null) return value;

		// replace type and value with the data
		if (type === "data") {
			let d = data[value];
			if (!d) return value; // if we can't find the data, return the key
			type = d.type;
			value = d.value;
		}

		switch (type) {
			case "table_id":
				var table = this.getTable(value);
				if (table) value = this.roll(table, data);
				else value = undefined;
				break;
			case "table":
				value = this.roll(value, data);
				break;
			case "dice":
				try {
					var d = new DiceExpression(value);
					value = d.roll().roll;
				} catch (e) {
					break;
				}

				break;
		}
		return value;
	}

	/**
	 * Like makeMixedThing but it's for .in child components
	 * @param  {[type]} child     [description]
	 * @param  {[type]} Table     [description]
	 * @param  {[type]} builtpack [description]
	 * @return {[type]}           [description]
	 */
	checkTypes(child, data = {}) {
		var gen, table;

		// data, replace
		if (child.type === "data") {
			let d = data[child.value];
			if (d) child = d; // swap
		}

		// now check
		if (child.type === "table") {
			table = child.value;
		} else if (child.type === "table_id") {
			table = this.getTable(child.value);
		} else if (child.type === "generator") {
			gen = this.builtpack.getGen(child.value);
		} else if (child.type === "embed") {
			// embed
			gen = child.value;
		} else if (typeof child.value === "string") {
			// string
			gen = this.builtpack.getGen(child.value); // if this is undefined that's okay
		}
		return { gen, table };
	}

	/**
	 * Extends if needs to
	 * @param  {[type]} genData   [description]
	 * @param  {[type]} builtpack [description]
	 * @return {[type]}           [description]
	 */
	cleanGen(genData) {
		if (!genData) {
			throw new Error("make(): genData cannot be undefined");
		}

		if (genData.chooseRandom) {
			var choices = [];
			for (var isa in this.builtpack.generators) {
				if (this.builtpack.generators[isa].extends === genData.isa) choices.push(isa);
			}
			if (choices.length) {
				isa = choices[Math.floor(Math.random() * choices.length)];
				genData = this.builtpack.getGen(isa);
				return this.cleanGen(genData);
			}
		}

		var gen;
		if (!genData.save) {
			var Generator = this.builtpack.model("Generator");
			gen = new Generator(genData);

			// SHOULD NOT EXTEND ON THE FLY
			// gen = gen.extend(builtpack);
		} else gen = genData;

		// this is an embedded generator, we need to extend
		if (!gen.isa) {
			gen = gen.extend(this.builtpack);
		}

		return gen;
	}

	//returns a Promise<String>
	// eslint-disable-next-line complexity
	roll(table, data) {
		if (table.returns === "fng") {
			try {
				var result = fng(
					table.rows[0] && table.rows[0].value,
					table.rows[1] && table.rows[1].value,
					1, // quantity
					(table.rows[2] !== undefined &&
						table.rows[2] !== null &&
						!isNaN(table.rows[2].value) &&
						table.rows[2].value) ||
						undefined
				)[0];
				if (table.rows[3] && table.rows[3].value) {
					return toUpper(result);
				}
				return result;
			} catch (e) {
				return null;
			}
		}

		if (table.concat) {
			return this.concatenate(table, data);
		}

		var row;
		if (table.rowWeights) row = weightedDiceChoose(table.rows);
		else if (table.tableWeight) row = weightedChoose(table.rows, table.tableWeight);
		else row = choose(table.rows);

		if (typeof row === "string") return row;

		return this.makeMixedThing(row, data);
	}

	concatenate(table, data) {
		var result = "";
		//for loop always results in a string
		for (var i = 0; i < table.rows.length; i++) {
			var rowResult = this.makeMixedThing(table.rows[i], data);
			result += rowResult;
		}

		return result;
	}

	makeStyle(gen, name) {
		if (!gen.style) return {};
		var arr = [
			this.makeMixedThing(gen.style.txt),
			this.makeMixedThing(gen.style.bg),
			gen.noAutoColor ? false : strToColor(name),
			this.makeIcon(gen.style.icon),
			this.makeMixedThing(gen.style.pattern)
		];
		return mergeStyle(arr, ["txt", "bg", "autoBG", "icon", "pattern"]);
	}

	makeIcon(icon) {
		if (!icon) return undefined;
		return {
			kind: icon && icon.category,
			value: this.makeMixedThing(icon)
		};
	}
}

/**
 * Takes an array of attributes and their labels and merges them into a single style object
 * @param  {string[]} arr    The values
 * @param  {string[]} labels The attribute names
 * @return {Object}        The unified style object
 */
function mergeStyle(arr, labels) {
	var style = {
		cls: []
	};
	var bg, autoBG;
	// eslint-disable-next-line complexity
	arr.forEach((val, i) => {
		if (labels[i] === "cls") style.cls.push(val);
		else if (labels[i] === "bg") bg = val ? "bg-" + val : undefined;
		else if (labels[i] === "autoBG") autoBG = val ? "bg-" + val : undefined;
		else if (labels[i] === "pattern") {
			if (val && !bg && !autoBG) style.cls.push("bg-grey-50"); // default bg if none supplied
			if (val) style.cls.push("ptn-" + val);
		} else style[labels[i]] = val;
	});
	if (autoBG) {
		style.cls.unshift(autoBG);
		style.txt = undefined;
	} else if (bg) {
		style.cls.unshift(bg);
	}
	style.cls = style.cls.join(" ").trim();
	if (!style.cls.length) style.cls = undefined;
	return style;
}

const strToColor = function(str) {
	if (typeof str !== "string") return false;

	var colors =
		"multicolored|opaline|rainbow|red|magenta|orange|yellow|teal|green|blue|turquoise|purple|gold|golden|glowing|shimmering|luminous|faint|white|black|brown|pale|silver|silvery|gray|tan|grey|pink|shady|sharkverse|baconverse|doughnutverse|lasagnaverse|" +
		Object.keys(colorConvert).join("|");

	str = " " + str.replace(/-/g, " ") + " ";
	var matches = str.match("^.*\\s(" + colors + ")\\s.*$");
	if (!matches) matches = str.match("^.*\\s(" + colors + ")ish\\s.*$");
	if (matches && matches[1]) str = matches[1];
	else return false;

	str = str.trim();

	for (var oldColor in colorConvert) {
		if (str === oldColor) str = colorConvert[oldColor];
	}

	if (!str) return false;

	return str.length ? str : false;
};

function choose(arr) {
	//Returns an element from an array at random.
	var result = arr[Math.floor(Math.random() * arr.length)];

	return result;
}

function weightedChoose(arr, weightChoose) {
	//Returns an element from an array at random according to a weight.
	//A weight of 2 means the first element will be picked roughly twice as often as the second; a weight of 0.5 means half as often. A weight of 1 gives a flat, even distribution.
	if (weightChoose <= 0 || weightChoose === undefined) weightChoose = 1;
	var result = arr[Math.floor(Math.pow(Math.random(), weightChoose) * arr.length)];

	return result;
}

// eslint-disable-next-line max-statements
function weightedDiceChoose(arr) {
	if (!(arr instanceof Array)) {
		throw new Error("arr must be instanceof Array");
	}

	var dSize = 0;
	var percentages = [];
	var value, weight;
	var row;

	arr = arr.slice();

	//sum weights
	for (var i = 0; i < arr.length; i++) {
		row = arr[i];
		if (row.weight) {
			value = row.value;
			weight = row.weight;
		} else if (typeof row === "string") {
			var parts = row.split(",");
			value = parts[0];
			weight = parts[1] ? parseInt(parts[1], 10) : 1;
		} else {
			value = row;
			weight = 1;
		}

		dSize += weight;
		percentages.push(weight);
		arr[i] = value;
	}
	var threshold = 0;
	var dRoll = rand(1, dSize);

	for (i = 0; i < percentages.length; i++) {
		threshold += percentages[i];
		if (dRoll <= threshold) {
			return arr[i];
		}
	}
}

module.exports = Maker;
