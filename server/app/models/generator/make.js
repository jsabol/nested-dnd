var Maker = {

	/**
	 * Make a thing that could be a tableid, a table, or a string
	 * @param  {string} options.type  tableid, table, or string
	 * @param  {Object|string} options.value the thing
	 * @param  {Table} Table         the table schema
	 * @return {string}              the random value
	 */
	makeMixedThing: function({type, value}, Table){
		if(value === undefined || value === null)
			return value;

		switch(type){
			case "table_id":
				return null; // TODO
				break;
			case "table":
				var table = new Table(value);
				return table.roll(); // TODO: roll
				break;
		}
		return value;
	},

	/**
	 * Creates a random version of a generator
	 * @param  {Generator} gen         the generator
	 * @param  {Integer} generations the number of nested levels to generate
	 * @param  {BuiltPack} builtpack        the compiled built pack with combined definitions of generators to use
	 * @param {Object} node the pre-existing node that we are generating children for
	 * @return {Object}             the node that will be passed to the user
	 */
	make: function(gen, generations, builtpack, node){
		if(!gen){
			console.trace("gen cannot be undefined");
			throw new Error("make(): gen cannot be undefined");
		}

		if(isNaN(generations) || generations < 0) generations = 0;

		//make into a Generator obj if not
		if(!gen.save){
			var Generator = builtpack.model('Generator');
			gen = new Generator(gen);
		}

		// make a new node if doesn't exist yet
		if(!node){
			node = {
				up: [] // placeholder for later
			};
			//optional fields, if new -----------------------------
		
			var txt = gen.makeTextColor;
			var cssClass =  gen.makeCssClass;
			var icon = gen.makeIcon;
			if(txt) node.txt = txt;
			if(cssClass) node.cssClass = cssClass;
			if(icon) node.icon = icon;
			if(gen.name) node.name = gen.name;
			if(gen.isa) node.isa = gen.isa;
			if(gen.in && gen.in.length) node.in = true; // placeholder for later;
		}
		
		// in ---------------------------------------------
		if(generations && gen.in && gen.in.length){
			var madeChildren = gen.in.map((c)=>{
				return this.makeChild(c, builtpack, generations-1);
			})

			//flatten madeChildren into single array
			var flatArray = [];
			madeChildren.forEach((child)=>{
				if(child instanceof Array){
					flatArray = flatArray.concat(child);
				}
				else if(child !== null){
					flatArray.push(child);
				}
			});

			node.in = flatArray;

			if(!madeChildren || madeChildren.length === 0){
				node.isEmpty = true;
			}
		}

		return node;
	},

	/**
	 * Processes the type of a child to randomly generate it
	 * @param  {Object} child       childSchema
	 * @param  {BuiltPack} builtpack   the compiled pack
	 * @param  {Integer} generations the number of nested levels to generate
	 * @return {Object[]}             an array of nodes that was generated by this child
	 */
	makeChild: function(child, builtpack, generations){
		// check chance
		if(!child.isIncluded) return null;

		const amount = child.makeAmount;

		var gen; 
		if(child.type === "generator"){
			gen = builtpack.generators[child.value]
		}
		if(child.type === "embed"){
			gen = child.value;
		}

		var arr = [];
		for(var i = 0; i < amount; i++){
			if(gen){
				arr.push(this.make(gen, generations, builtpack))
			}
			else arr.push({ 
				name: child.value,
				up: [],
				in: false
			});
		}

		return arr;
	}

}

module.exports = Maker;